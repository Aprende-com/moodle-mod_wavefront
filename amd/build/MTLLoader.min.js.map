{"version":3,"file":"MTLLoader.min.js","sources":["../src/MTLLoader.js"],"sourcesContent":["import {\n\tColor,\n\tDefaultLoadingManager,\n\tFileLoader,\n\tFrontSide,\n\tLoader,\n\tLoaderUtils,\n\tMeshPhongMaterial,\n\tRepeatWrapping,\n\tTextureLoader,\n\tVector2,\n\tsRGBEncoding\n} from 'mod_wavefront/three';\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nclass MTLLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Loads and parses a MTL asset from a URL.\n\t *\n\t * @param {String} url - URL to the MTL file.\n\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\n\t * @param {Function} [onProgress] - Callback for download progress.\n\t * @param {Function} [onError] - Callback for download errors.\n\t *\n\t * @see setPath setResourcePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setResourcePath() explicitly prior to load.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tsetMaterialOptions( value ) {\n\n\t\tthis.materialOptions = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses a MTL file.\n\t *\n\t * @param {String} text - Content of MTL file\n\t * @return {MaterialCreator}\n\t *\n\t * @see setPath setResourcePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setResourcePath() explicitly prior to parse.\n\t */\n\tparse( text, path ) {\n\n\t\tconst lines = text.split( '\\n' );\n\t\tlet info = {};\n\t\tconst delimiter_pattern = /\\s+/;\n\t\tconst materialsInfo = {};\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlet line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst pos = line.indexOf( ' ' );\n\n\t\t\tlet key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tlet value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\n\t\t\tvalue = value.trim();\n\n\t\t\tif ( key === 'newmtl' ) {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t} else {\n\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\n\n\t\t\t\t\tconst ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst materialCreator = new MaterialCreator( this.resourcePath || path, this.materialOptions );\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\tmaterialCreator.setManager( this.manager );\n\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\treturn materialCreator;\n\n\t}\n\n}\n\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nclass MaterialCreator {\n\n\tconstructor( baseUrl = '', options = {} ) {\n\n\t\tthis.baseUrl = baseUrl;\n\t\tthis.options = options;\n\t\tthis.materialsInfo = {};\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t\tthis.crossOrigin = 'anonymous';\n\n\t\tthis.side = ( this.options.side !== undefined ) ? this.options.side : FrontSide;\n\t\tthis.wrap = ( this.options.wrap !== undefined ) ? this.options.wrap : RepeatWrapping;\n\n\t}\n\n\tsetCrossOrigin( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t}\n\n\tsetManager( value ) {\n\n\t\tthis.manager = value;\n\n\t}\n\n\tsetMaterials( materialsInfo ) {\n\n\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t}\n\n\tconvert( materialsInfo ) {\n\n\t\tif ( ! this.options ) return materialsInfo;\n\n\t\tconst converted = {};\n\n\t\tfor ( const mn in materialsInfo ) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tconst mat = materialsInfo[ mn ];\n\n\t\t\tconst covmat = {};\n\n\t\t\tconverted[ mn ] = covmat;\n\n\t\t\tfor ( const prop in mat ) {\n\n\t\t\t\tlet save = true;\n\t\t\t\tlet value = mat[ prop ];\n\t\t\t\tconst lprop = prop.toLowerCase();\n\n\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( save ) {\n\n\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn converted;\n\n\t}\n\n\tpreload() {\n\n\t\tfor ( const mn in this.materialsInfo ) {\n\n\t\t\tthis.create( mn );\n\n\t\t}\n\n\t}\n\n\tgetIndex( materialName ) {\n\n\t\treturn this.nameLookup[ materialName ];\n\n\t}\n\n\tgetAsArray() {\n\n\t\tlet index = 0;\n\n\t\tfor ( const mn in this.materialsInfo ) {\n\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\tindex ++;\n\n\t\t}\n\n\t\treturn this.materialsArray;\n\n\t}\n\n\tcreate( materialName ) {\n\n\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\tthis.createMaterial_( materialName );\n\n\t\t}\n\n\t\treturn this.materials[ materialName ];\n\n\t}\n\n\tcreateMaterial_( materialName ) {\n\n\t\t// Create material\n\n\t\tconst scope = this;\n\t\tconst mat = this.materialsInfo[ materialName ];\n\t\tconst params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfunction resolveURL( baseUrl, url ) {\n\n\t\t\tif ( typeof url !== 'string' || url === '' )\n\t\t\t\treturn '';\n\n\t\t\t// Absolute URL\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\n\n\t\t\treturn baseUrl + url;\n\n\t\t}\n\n\t\tfunction setMapForType( mapType, value ) {\n\n\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\n\n\t\t\tconst texParams = scope.getTextureParams( value, params );\n\t\t\tconst map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\n\n\t\t\tmap.repeat.copy( texParams.scale );\n\t\t\tmap.offset.copy( texParams.offset );\n\n\t\t\tmap.wrapS = scope.wrap;\n\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\tif ( mapType === 'map' || mapType === 'emissiveMap' ) {\n\n\t\t\t\tmap.encoding = sRGBEncoding;\n\n\t\t\t}\n\n\t\t\tparams[ mapType ] = map;\n\n\t\t}\n\n\t\tfor ( const prop in mat ) {\n\n\t\t\tconst value = mat[ prop ];\n\t\t\tlet n;\n\n\t\t\tif ( value === '' ) continue;\n\n\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams.color = new Color().fromArray( value ).convertSRGBToLinear();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams.specular = new Color().fromArray( value ).convertSRGBToLinear();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ke':\n\n\t\t\t\t\t// Emissive using RGB values\n\t\t\t\t\tparams.emissive = new Color().fromArray( value ).convertSRGBToLinear();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tsetMapForType( 'map', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t// Specular map\n\n\t\t\t\t\tsetMapForType( 'specularMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ke':\n\n\t\t\t\t\t// Emissive map\n\n\t\t\t\t\tsetMapForType( 'emissiveMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'norm':\n\n\t\t\t\t\tsetMapForType( 'normalMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tsetMapForType( 'bumpMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_d':\n\n\t\t\t\t\t// Alpha map\n\n\t\t\t\t\tsetMapForType( 'alphaMap', value );\n\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams.shininess = parseFloat( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( n < 1 ) {\n\n\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tr':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( this.options && this.options.invertTrProperty ) n = 1 - n;\n\n\t\t\t\t\tif ( n > 0 ) {\n\n\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.materials[ materialName ] = new MeshPhongMaterial( params );\n\t\treturn this.materials[ materialName ];\n\n\t}\n\n\tgetTextureParams( value, matParams ) {\n\n\t\tconst texParams = {\n\n\t\t\tscale: new Vector2( 1, 1 ),\n\t\t\toffset: new Vector2( 0, 0 )\n\n\t\t };\n\n\t\tconst items = value.split( /\\s+/ );\n\t\tlet pos;\n\n\t\tpos = items.indexOf( '-bm' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\n\t\t\titems.splice( pos, 2 );\n\n\t\t}\n\n\t\tpos = items.indexOf( '-s' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\tpos = items.indexOf( '-o' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\ttexParams.url = items.join( ' ' ).trim();\n\t\treturn texParams;\n\n\t}\n\n\tloadTexture( url, mapping, onLoad, onProgress, onError ) {\n\n\t\tconst manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager;\n\t\tlet loader = manager.getHandler( url );\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = new TextureLoader( manager );\n\n\t\t}\n\n\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\n\t\tconst texture = loader.load( url, onLoad, onProgress, onError );\n\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t}\n\n}\n\nexport { MTLLoader };\n"],"names":["MTLLoader","Loader","constructor","manager","load","url","onLoad","onProgress","onError","scope","this","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterialOptions","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","undefined","FrontSide","wrap","RepeatWrapping","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","create","getIndex","materialName","getAsArray","index","createMaterial_","params","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","test","repeat","copy","scale","offset","wrapS","wrapT","encoding","sRGBEncoding","n","color","Color","fromArray","convertSRGBToLinear","specular","emissive","transparent","shininess","opacity","invertTrProperty","MeshPhongMaterial","matParams","Vector2","items","bumpScale","splice","set","join","mapping","DefaultLoadingManager","getHandler","TextureLoader","texture"],"mappings":"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"}